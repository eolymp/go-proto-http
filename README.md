# go-proto-http

This protobuf code generator generates Go HTTP bindings for RPC services defined in `.proto` files. 
It uses Google API HTTP protobuf extension to resolve HTTP parameters (path, method etc) for each method and creates Go `http.Handler` to apply routing, marshalling and unmarshalling.

Only few basic features of Google API HTTP annotations are supported at the moment.

## Installation

```
go get github.com/eolymp/go-proto-http/cmd/protoc-gen-go-http
```

## Usage

Just like with any other code generator you need to run `protoc` with `go-http_out` flag. This code generator requires data structures and interfaces generated by `go` and `go-grpc` code generators, so they should be enabled too.

```
protoc --go_out=build  --go-grpc_out=build --go-http_out=build your.proto
```

Generated code looks something like this:

```go
// ...

// NewUserManagerHandler constructs new http.Handler for UserManagerServer
func NewUserManagerHandler(srv UserManagerServer) http.Handler {
	router := mux.NewRouter()
	router.Handle("/users", _UserManager_ListUsers_HTTP_Handler(srv)).Methods("GET")

	return router
}

func _UserManager_ListUsers_HTTP_Handler(srv UserManagerServer) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		in := &ListUsersInput{}

		if err := _UserManager_HTTPReadRequestBody(r, in); err != nil {
			_UserManager_HTTPWriteErrorResponse(w, err)
			return
		}

		out, err := srv.ListUsers(r.Context(), in)
		if err != nil {
			_UserManager_HTTPWriteErrorResponse(w, err)
			return
		}

		_UserManager_HTTPWriteResponse(w, out)
	})
}
```

Then, generated HTTP handler can be used in your application with HTTP server:

```go
router := mux.NewRouter()

router.PathPrefix("/users").
	Handler(userspb.NewUserManagerHandler(users.NewServer(db.DB)))

srv := &http.Server{
	Addr:    ":8080",
	Handler: router,
}

if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
	log.Fatal("HTTP api has failed:", err)
}
```
