package main

import (
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
)

const (
	httpPackage      = protogen.GoImportPath("net/http")
	muxPackage       = protogen.GoImportPath("github.com/gorilla/mux")
	jsonPackage      = protogen.GoImportPath("encoding/json")
	ioutilPackage    = protogen.GoImportPath("io/ioutil")
	protoPackage     = protogen.GoImportPath("google.golang.org/protobuf/proto")
	protojsonPackage = protogen.GoImportPath("google.golang.org/protobuf/encoding/protojson")
	statusPackage    = protogen.GoImportPath("google.golang.org/grpc/status")
	codesPackage     = protogen.GoImportPath("google.golang.org/grpc/codes")
)

// GenerateFile generates a _grpc.pb.go file containing gRPC service definitions.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "_http.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-http. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	GenerateFileContent(gen, file, g)
	return g
}

// GenerateFileContent generates the gRPC service definitions, excluding the package statement.
func GenerateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Services) == 0 {
		return
	}

	for _, service := range file.Services {
		genService(gen, file, g, service)
	}
}

func genService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	genServiceHelpers(gen, file, g, service)
	genServiceConstructor(gen, file, g, service)
	genServiceHandlers(gen, file, g, service)
}

func genServiceHelpers(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	g.P("// _", service.GoName, "_HTTPReadRequestBody parses body to proto.Message")
	g.P("func _", service.GoName, "_HTTPReadRequestBody(r *", httpPackage.Ident("Request"), ", v ", protoPackage.Ident("Message"), ") error {")
	g.P("    data, err := ", ioutilPackage.Ident("ReadAll"), "(r.Body)")
	g.P("    if err != nil {")
	g.P("        return err")
	g.P("    }")
	g.P()
	g.P("    if err := ", protojsonPackage.Ident("Unmarshal"), "(data, v); err != nil {")
	g.P("        return err")
	g.P("    }")
	g.P()
	g.P("    return nil")
	g.P("}")

	g.P("// _", service.GoName, "_HTTPWriteResponse writes proto.Message to HTTP response")
	g.P("func _", service.GoName, "_HTTPWriteResponse(w ", httpPackage.Ident("ResponseWriter"), ", v ", protoPackage.Ident("Message"), ") {")
	g.P("    data, err := ", protojsonPackage.Ident("Marshal"), "(v)")
	g.P("    if err != nil {")
	g.P("        _", service.GoName, "_HTTPWriteErrorResponse(w, err)")
	g.P("        return")
	g.P("    }")
	g.P()
	g.P("    w.Header().Set(\"Content-Type\", \"application/json\")")
	g.P("    w.WriteHeader(", httpPackage.Ident("StatusOK"), ")")
	g.P()
	g.P("    _, _ = w.Write(data)")
	g.P("}")

	g.P("// _", service.GoName, "_HTTPErrorParams keeps data structure for errors response")
	g.P("type _", service.GoName, "_HTTPErrorParams struct {")
	g.P("    Code string `json:\"code,omitempty\"`")
	g.P("    Message string `json:\"error,omitempty\"`")
	g.P("    Details []interface{} `json:\"details,omitempty\"`")
	g.P("}")

	g.P("// _", service.GoName, "_HTTPWriteErrorResponse writes error to HTTP response with error status code")
	g.P("func _", service.GoName, "_HTTPWriteErrorResponse(w ", httpPackage.Ident("ResponseWriter"), ", e error) {")
	g.P("    s := ", statusPackage.Ident("Convert"), "(e)")
	g.P()
	g.P("    w.Header().Set(\"Content-Type\", \"application/json\")")
	g.P()
	g.P("    switch(s.Code()) {")
	g.P("    case ", codesPackage.Ident("OK"), ": w.WriteHeader(", httpPackage.Ident("StatusOK"), ")")
	g.P("    case ", codesPackage.Ident("Canceled"), ": w.WriteHeader(", httpPackage.Ident("StatusGatewayTimeout"), ")")
	g.P("    case ", codesPackage.Ident("Unknown"), ": w.WriteHeader(", httpPackage.Ident("StatusInternalServerError"), ")")
	g.P("    case ", codesPackage.Ident("InvalidArgument"), ": w.WriteHeader(", httpPackage.Ident("StatusBadRequest"), ")")
	g.P("    case ", codesPackage.Ident("DeadlineExceeded"), ": w.WriteHeader(", httpPackage.Ident("StatusGatewayTimeout"), ")")
	g.P("    case ", codesPackage.Ident("NotFound"), ": w.WriteHeader(", httpPackage.Ident("StatusNotFound"), ")")
	g.P("    case ", codesPackage.Ident("AlreadyExists"), ": w.WriteHeader(", httpPackage.Ident("StatusConflict"), ")")
	g.P("    case ", codesPackage.Ident("PermissionDenied"), ": w.WriteHeader(", httpPackage.Ident("StatusForbidden"), ")")
	g.P("    case ", codesPackage.Ident("ResourceExhausted"), ": w.WriteHeader(", httpPackage.Ident("StatusInsufficientStorage"), ")")
	g.P("    case ", codesPackage.Ident("FailedPrecondition"), ": w.WriteHeader(", httpPackage.Ident("StatusPreconditionFailed"), ")")
	g.P("    case ", codesPackage.Ident("Aborted"), ": w.WriteHeader(", httpPackage.Ident("StatusServiceUnavailable"), ")")
	g.P("    case ", codesPackage.Ident("OutOfRange"), ": w.WriteHeader(", httpPackage.Ident("StatusRequestedRangeNotSatisfiable"), ")")
	g.P("    case ", codesPackage.Ident("Unimplemented"), ": w.WriteHeader(", httpPackage.Ident("StatusNotImplemented"), ")")
	g.P("    case ", codesPackage.Ident("Internal"), ": w.WriteHeader(", httpPackage.Ident("StatusInternalServerError"), ")")
	g.P("    case ", codesPackage.Ident("Unavailable"), ": w.WriteHeader(", httpPackage.Ident("StatusServiceUnavailable"), ")")
	g.P("    case ", codesPackage.Ident("DataLoss"), ": w.WriteHeader(", httpPackage.Ident("StatusInternalServerError"), ")")
	g.P("    case ", codesPackage.Ident("Unauthenticated"), ": w.WriteHeader(", httpPackage.Ident("StatusUnauthorized"), ")")
	g.P("    default: w.WriteHeader(", httpPackage.Ident("StatusInternalServerError"), ")")
	g.P("    }")
	g.P()
	g.P("    err := ", jsonPackage.Ident("NewEncoder"), "(w).Encode(&_", service.GoName, "_HTTPErrorParams{")
	g.P("        Code: s.Code().String(),")
	g.P("        Message: s.Message(),")
	g.P("        Details: s.Details(),")
	g.P("    })")
	g.P()
	g.P("    if err != nil {")
	g.P("        panic(err)")
	g.P("     }")
	g.P("}")
}

func genServiceConstructor(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	g.P("// New", service.GoName, "Handler constructs new http.Handler for ", service.GoName, "Server")
	g.P("func New", service.GoName, "Handler(srv ", service.GoName, "Server) ", httpPackage.Ident("Handler"), " {")
	g.P("    router := ", muxPackage.Ident("NewRouter"), "()")

	for _, method := range service.Methods {
		handler := fmt.Sprintf("_%v_%v_HTTP_Handler", service.GoName, method.GoName)
		bindings := getHTTPBindings(method)

		for _, binding := range bindings {
			g.P("    router.Handle(", fmt.Sprintf("%#v", binding.Path), ", ", handler, "(srv)).Methods(", fmt.Sprintf("%#v", binding.Method), ")")
		}
	}

	g.P("    return router")
	g.P("}")
}

func genServiceHandlers(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service) {
	for _, method := range service.Methods {
		bindings := getHTTPBindings(method)

		for _, binding := range bindings {
			handler := fmt.Sprintf("_%v_%v_HTTP_Handler", service.GoName, method.GoName)

			g.P()

			g.P("func ", handler, "(srv ", service.GoName, "Server) ", httpPackage.Ident("Handler"), " {")
			g.P("    return ", httpPackage.Ident("HandlerFunc"), "(func(w ", httpPackage.Ident("ResponseWriter"), ", r *", httpPackage.Ident("Request"), ") {")
			g.P("		in := &", method.Input.GoIdent, "{}")
			g.P()

			if binding.RequestBody == "*" {
				g.P("		if err := _", service.GoName, "_HTTPReadRequestBody(r, in); err != nil {")
				g.P("			_", service.GoName, "_HTTPWriteErrorResponse(w, err)")
				g.P("			return")
				g.P("		}")
				g.P()
			}

			if len(binding.Parameters) != 0 {
				g.P("		vars := ", muxPackage.Ident("Vars"), "(r)")
				for _, name := range binding.Parameters {
					field, ok := getMessageField(method.Input, name)
					if !ok {
						panic(fmt.Errorf("unable to resolve field %#v in %#v", name, method.Input.Desc.FullName()))
					}

					g.P("		in.", field.GoName, " = vars[", fmt.Sprintf("%#v", name), "]")
				}

				g.P()
			}

			g.P("		out, err := srv.", method.GoName, "(r.Context(), in)")
			g.P("		if err != nil {")
			g.P("			_", service.GoName, "_HTTPWriteErrorResponse(w, err)")
			g.P("			return")
			g.P("		}")
			g.P()
			g.P("		_", service.GoName, "_HTTPWriteResponse(w, out)")
			g.P("    })")
			g.P("}")
		}
	}
}

func getMessageField(m *protogen.Message, name string) (*protogen.Field, bool) {
	for _, f := range m.Fields {
		if string(f.Desc.Name()) == name {
			return f, true
		}
	}

	return nil, false
}
